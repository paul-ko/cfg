. ~/git/cfg/bash/bashrc.sh
ITUNES_XML=/e/iTunes\ Library.xml
HORROR_NOTES="${HOME}/Dropbox/Movies/horror-notes.md"
export HORROR_NOTES

HISTCONTROL=ignoreboth
shopt -s histappend
HISTSIZE=1000
HISTFILESIZE=2000
shopt -s checkwinsize

alias vlc="/c/Program\ Files\ \(x86\)/VideoLAN/VLC/vlc.exe"

# too slow
bashroll() {
    verbose=0
    if [[ ! -z "$2" ]]; then
        verbose=1
    fi
    if ! echo "$1" | grep -qP "^\d*d\d+([+-]\d*)?$"; then
        echo Bad specifier!
        return 1
    fi
    count=1
    if echo "$1" | grep -qP "^\d+"; then
        count=$(echo "$1" | grep -oP "^\d+")
    fi
    die=$(echo "$1" | grep -oP "(?<=d)\d+")
    modifier=0
    if echo "$1" | grep -qP "\+"; then
        modifier=$(echo "$1" | grep -oP "(?<=\+)\d+")
    elif echo "$1" | grep -qP -- "-"; then
        modifier=$(echo "$1" | grep -oP -- "-\d+")
    fi
    amount=0
    for _ in $(seq $count); do
        roll=$(shuf -n1 -i 1-$die)
        amount=$(( amount + roll ))
        if [[ $verbose -eq 1 ]]; then
            printf "...rolled %s\n" $roll
        fi
    done
    if [[ $verbose -eq 1 && $count -gt 1 ]]; then
        printf "...equals %s\n" $amount
    fi
    amount=$(( amount + modifier ))
    echo $amount
}

roll() {
    if [[ -z "$1" ]]; then
        printf "Must specify the roll to make!\n"
        return 1
    fi
    python -c '
import random
import re
import sys

instruction = sys.argv[1]
roll_count = int(sys.argv[2]) if len(sys.argv[2]) else 1
quiet = len(sys.argv[3])

pattern = "^(\\d+)?d(\\d+)([\+-]\\d+)?$"
if (match := re.match(pattern, instruction)) is None:
    print("Must specify a valid dice roll!")
    sys.exit(1)
if (count := match.group(1)) is None:
    count = 1
else:
    count = int(count)
if (die := int(match.group(2))) < 1:
    print("Must specify a valid number of sides!")
    sys.exit(1)
if (modifier := match.group(3)) is None:
    modifier = 0
else:
    modifier = int(match.group(3))

# print(f"{count=} {die=} {modifier=}")
for _ in range(roll_count):
    amount = modifier
    for _ in range(count):
        result = random.randint(1, die)
        if not quiet:
            print(f"...rolling d{die}: {result}")
        amount += result
    print(amount)
' "$1" "$2" "$3"
}

test_tunes() {
    r it
    name=tunes.db
    if [ -f ./$name ]; then
        rm $name
    fi
    if [[ ! -z "$1" ]]; then
        time pipenv run load --from "$ITUNES_XML" --to $name --verbose
    else
        time pipenv run load --from "$ITUNES_XML" --to $name
    fi
}

rep_tunes() {
    count=${1:-10}
    if [[ "$count" -lt 1 ]]; then
        printf "count must be at least 1\n"
        return
    fi
    r it
    name=tunes.db
    if [ -f ./$name ]; then
        rm $name
    fi
    time (for _ in $(seq $count); do
        pipenv run load --from "$ITUNES_XML" --to $name | grep Done && rm ./$name
    done)
}

hc() {
    line_no=$(grep -n '^\* [^\*]' "$HORROR_NOTES" | tail -1 | cut -f1 -d":")
    printf "Line no: %d (" $line_no
    sed -n "s/$/)/; ${line_no}p;" "$HORROR_NOTES"
    tail -n +$line_no "$HORROR_NOTES" | grep -Pc '^### [^\[]'
}

music_update() {
    find "$ITUNES_XML" -printf '%Tb %Td %TH:%TM\n'
}

v() {
    name=./a1.flv
    if [[ -f $name ]]; then
        rm $name
    fi
    cp "$1" $name
    vlc $name
}

problem=/D/videos

alias pr="cd $problem"
